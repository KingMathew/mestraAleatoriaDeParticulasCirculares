<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <title>Three.js Full Window Demo</title>
    <style>
        html,
        body {
            margin: 0;
            overflow: hidden;
        }
        
        canvas {
            display: block;
        }
    </style>
    <script src="three.min.js"></script>
    <script src="TrackballControls.js"></script>
    <script>
        var scene, camera, renderer;
        var canvas;
        var controls;
        var cameraAndLight;
        var balls = [];
        var BALL_COUNT = 244;
        var base = 20;
        var height = 20;
        var deepth = 20;
        var lim = (base / 2) - 1;

        function createWorld() {

            renderer.setClearColor(0);
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(28, window.innerWidth / window.innerHeight, 0.1, 100);
            var light = new THREE.DirectionalLight();
            var clock;
            light.position.set(0, 0, 1);
            camera.position.set(25, 40, 50);
            camera.lookAt(scene.position);
            camera.add(light);
            scene.add(camera);

            var cube = new THREE.Mesh(
                new THREE.BoxGeometry(base, height, deepth),
                new THREE.MeshPhongMaterial({
                    polygonOffset: true,
                    polygonOffsetUnits: 1,
                    polygonOffsetFactor: 1,
                    color: "white",
                    specular: 0x202020,
                    transparent: true,
                    opacity: 0.3
                })
            );
            scene.add(cube);

            var edgeGeometry = new THREE.EdgesGeometry(cube.geometry);
            cube.add(new THREE.LineSegments(edgeGeometry, new THREE.LineBasicMaterial({
                color: 0xffffff
            })));

            var geom = new THREE.SphereGeometry(1, 20, 12);
            for (var i = 0; i < BALL_COUNT; i++) {
                var ball = {};
                balls.push(ball);

                ball.obj = new THREE.Mesh(
                    geom,
                    new THREE.MeshPhongMaterial({
                        color: Math.floor(Math.random() * 0x1000000),
                        specular: 0x080808,
                        shininess: 32
                    })
                );

                ball.x = lim * 2 * Math.random() - lim;
                ball.y = lim * 2 * Math.random() - lim;
                ball.z = lim * 2 * Math.random() - lim;
                ball.dx = Math.random() * 6 + 2;
                ball.dy = Math.random() * 6 + 2;
                ball.dz = Math.random() * 6 + 2;
                if (Math.random() < 0.5)
                    ball.dx = -ball.dx;
                if (Math.random() < 0.5)
                    ball.dy = -ball.dy;
                if (Math.random() < 0.5)
                    ball.dz = -ball.dz;

                ball.obj.position.set(ball.x, ball.y, ball.z);
                scene.add(ball.obj);
            }
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateForFrame() {
            var dt = clock.getDelta();
            for (var i = 0; i < balls.length; i++) {
                var ball = balls[i];

                ball.x += ball.dx * dt;
                ball.y += ball.dy * dt;
                ball.z += ball.dz * dt;

                /* if ball has moved outside the cube, reflect it back into the cube */
                if (ball.x > lim) {
                    ball.x -= 2 * (ball.x - lim);
                    ball.dx = -Math.abs(ball.dx);
                } else if (ball.x < -lim) {
                    ball.x += 2 * (-lim - ball.x);
                    ball.dx = Math.abs(ball.dx);
                }
                if (ball.y > lim) {
                    ball.y -= 2 * (ball.y - lim);
                    ball.dy = -Math.abs(ball.dy);
                } else if (ball.y < -lim) {
                    ball.y += 2 * (-lim - ball.y);
                    ball.dy = Math.abs(ball.dy);
                }
                if (ball.z > lim) {
                    ball.z -= 2 * (ball.z - lim);
                    ball.dz = -Math.abs(ball.dz);
                } else if (ball.z < -lim) {
                    ball.z += 2 * (-lim - ball.z);
                    ball.dz = Math.abs(ball.dz);
                }

                ball.obj.position.set(ball.x, ball.y, ball.z);
            }
        }


        function doFrame() {
            updateForFrame();
            controls.update();
            render();
            requestAnimationFrame(doFrame);
        }


        function doResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }


        function init() {
            try {
                try {
                    renderer = new THREE.WebGLRenderer({
                        antialias: true
                    });
                } catch (e) {
                    document.body.innerHTML = "<h3><b>Sorry, WebGL is required but is not available.</b><h3>";
                    return;
                }
                canvas = renderer.domElement;
                renderer.setSize(window.innerWidth, window.innerHeight);
                window.addEventListener("resize", doResize, false);
                document.body.appendChild(canvas);
                clock = new THREE.Clock();
                createWorld();
                controls = new THREE.TrackballControls(camera, canvas);
                controls.noPan = true;
                controls.noZoom = true;
                requestAnimationFrame(doFrame);
            } catch (e) {
                document.body.innerHTML = "<h3><b>Sorry, an error occurred:<br>" + e + "</b></h3>";
            }
        }
    </script>
</head>

<body onload="init()">

</body>

</html>